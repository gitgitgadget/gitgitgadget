#!/usr/bin/env node

/*
 * This script is intended to help submit patch series to projects which want
 * contributions to be sent to a mailing list. The process is not quite as
 * painless for the contributor as opening Pull Requests, but at least it is
 * much less painful than having to all the steps manually.
 *
 * Example usage:
 *
 *	/path/to/mail-patch-series.sh
 *
 * (All relevant information, such as the mailing list to which this patch
 * series needs to be sent, the current iteration of the patch series, etc is
 * inferred from the current branch in the current repository.)
 *
 * Currently, this script supports submitting patch series (or single patches)
 * to only two projects: Git and Cygwin, with the upstream remotes being called
 * 'upstream' and 'cygwin', respectively.
 *
 * To make use of this script, you first have to have a topic branch. It needs
 * to be rebased to the latest `master` (or `next` in the case of Git).
 *
 * Further, you need an alias called `send-mbox` that takes an mbox on stdin
 * and puts the individual mails into the Drafts folder of your maildir, ready
 * to send. Example for alias.send-mbox:
 *
 * [alias]
 *    send-mbox = !git mailsplit -o\"$HOME\"/Mail/Drafts/new
 *
 * When running this script on a newer iteration of the same topic branch, it
 * will detect that and use the appropriate [PATCH v<iteration>] prefix.
 *
 * This script will also use the branch description as cover letter. Unlike
 * plain format-patch, the first line will be used as subject and the rest as
 * mail body, without any ugly "*** Subject/Blurb here ***".
 *
 * Note that this script will demand a branch description (which can be added
 * or edited using `git branch --edit-description`) if the current topic branch
 * contains more that a single patch; For single-patch "series", the branch
 * description is optional.
 *
 * This script will also try to Cc: original authors when sending patches on
 * their behalf, and people mentioned in the Cc: footer of commit messages.
 *
 * To Cc: the entire patch series to, say, reviewers who commented on some
 * iteration of the patch series, the script supports being called with the
 * `--cc 'R E Viewer <reviewer@email.com>'` option; This information is then
 * stored in the config, and used when sending the next iteration.
 *
 * Furthermore, for a second or later iteration of a patch series, this script
 * will insert an branch-diff (currently generated by tbdiff from
 * https://github.com/trast/tbdiff), and reply to the cover letter of the
 * previous iteration. It stores the relevant information in local tags whose
 * names reflect the branch name and the iteration.
 *
 * Lastly, if the mail.publishtoremote is set in the config, the branch as well
 * as the generated tag(s) will be pushed to the remote of that name. If this
 * remote's URL points to GitHub, the URL to the tag will be sent together with
 * the patch series.
 *
 * If anything goes awry, an iteration can be regenerated/resent with the
 * `--redo` option.
 */

function die(err: string): void {
	process.stderr.write(err + '\n');
	process.exit(1);
};

interface GitOptions {
	input: string;
	gentle: boolean;
}

function callGitSync(args: String[], options: GitOptions = {} as GitOptions): string {
	try {
		var child_process = require('child_process');
		if (typeof(options['input']) == 'undefined')
			options['input'] = '';
		var result = child_process.spawnSync('git', args, options);
		var err = '' + result.stderr;
		!err || process.stderr.write(err + '\n');
		if ((typeof(options['gentle']) == 'undefined' ||
		     !options['gentle']) && result.status !== 0)
			die('git ' + args.join(' ') + ' failed with status ' +
				result.status);

		return ('' + result.stdout).replace(/\n$/, '');
	} catch (err) {
		die(err);
	}
	return '';
};

function gitConfig(key: string): string {
	return callGitSync(['config', key], { gentle: true } as GitOptions);
};

gitConfig('alias.send-mbox') ||
die("Need an 'send-mbox' alias");

// figure out the iteration of this patch series
var branchname: string;

function getBranchName(): string {
	branchname = callGitSync(['rev-parse', '--symbolic-full-name', 'HEAD']);
	var match = branchname.match(/^refs\/heads\/(.*)/);
	match ||
	die('Not on a branch (' + branchname + ')?');
	return match![1];
};

var redo = false;
var dryRun = false;
var rfc = false;
var publishtoremote = gitConfig('mail.publishtoremote');
var patience: string | null = null;

function parseCommandLineOptions(argv: String[]): void {
	var i, match;
	for (i = 2; i < argv.length; i++) {
		var arg = argv[i];
		if (arg == '--redo') redo = true;
		else if (arg == '--dry-run' || arg == '-n') dryRun = true;
		else if (arg == '--rfc') rfc = true;
		else if (match = arg.match(/^--publish-to-remote=.*/))
			publishtoremote = match[1];
		else if (arg == '--patience') patience = '--patience';
		else if (arg == '--cc') {
			var key = 'branch.' + shortname + '.cc';
			arg = i + 1 < argv.length ? argv[++i] : '';
			i + 1 == argv.length ||
			die('Too many arguments');
			if (!arg)
				console.log(callGitSync(['config', '--get-all', key], { gentle: true } as GitOptions));
			else if (arg.match(/>.*>/) || arg.match(/>,/)) {
				arg.replace(/> /g, '>,').split(',').map(function(email: string) {
					email = email.trim();
					!email ||
					callGitSync(['config', '--add', key, email]);
				});
			} else if (arg.match(/@/))
				callGitSync(['config', '--add', key, arg]);
			else {
				var id = callGitSync(['log', '-1', '--format=%an <%ae>',
						     '--author=' + arg]);
				id ||
				die('Not an email address: ' + arg);
				console.log("Adding Cc: " + id);
				callGitSync(['config', '--add', key, id]);
			}
			process.exit(0);
		} else if (match = arg.match(/^--basedon=(.*)/)) {
			var key = 'branch.' + shortname + '.basedon';
			callGitSync(['config', key, arg]);
			process.exit(0);
		} else if (arg == '--basedon') {
			var key = 'branch.' + shortname + '.basedon';
			if (i + 1 == argv.length)
				console.log(gitConfig(key));
			else if (i + 2 == argv.length)
				callGitSync(['config', key, argv[++i]]);
			else
				die('Too many arguments');
			process.exit(0);
		} else
			break;
	}

	if (i < argv.length)
		die('Usage: ' + argv[1] +
		    ' [--redo] [--publish-to-remote=<remote>] |\n' +
		    '--cc [<email-address>] | --basedon [<branch>]');

	if (!publishtoremote || !gitConfig('remote.' + publishtoremote + '.url'))
		die('No valid remote: ' + publishtoremote);
};

function commitExists(commit: string): boolean {
	try {
		var child_process = require('child_process');
		var p = child_process.spawnSync('git', ['rev-parse', '--verify',
						commit], { input: '' });
		if (typeof(p.status) == 'undefined' || p.status != 0)
			return false;
		return true;
	} catch (err) {
		return false;
	}
}

// For now, only the Git and Cygwin projects are supported
var to: string, cc: string[] = [], upstreamBranch: string;
var midUrlPrefix = ' Message-ID: ';

function determineProject(): void {
	if (commitExists('e83c5163316f89bfbde')) {
		// Git
		to = '--to=git@vger.kernel.org';
		cc.push('Junio C Hamano <gitster@pobox.com>');
		upstreamBranch = 'upstream/pu';
		if (callGitSync(['rev-list', branchname + '..' + upstreamBranch]))
			upstreamBranch = 'upstream/next';
		if (callGitSync(['rev-list', branchname + '..' + upstreamBranch]))
			upstreamBranch = 'upstream/master';
		midUrlPrefix = 'https://public-inbox.org/git/';
	} else if (commitExists('a3acbf46947e52ff596')) {
		// Cygwin
		to = '--to=cygwin-patches@cygwin.com';
		upstreamBranch = 'cygwin/master';
		midUrlPrefix = 'https://www.mail-archive.com/search?l=cygwin-patches@cygwin.com&q=';
	} else if (commitExists('cc8ed39b240180b5881')) {
		// BusyBox
		to = '--to=busybox@busybox.net';
		upstreamBranch = 'busybox/master';
		midUrlPrefix = 'https://www.mail-archive.com/search?l=busybox@busybox.net&q=';
	} else
		die('Unrecognized project');
};

var basedon: string;

function determineBaseBranch(): void {
	basedon = gitConfig('branch.' + shortname + '.basedon');
	if (basedon && commitExists(basedon)) {
		publishtoremote ||
		die('Need a remote to publish to');

		var remoteRef = 'refs/remotes/' + publishtoremote + '/' + basedon;
		if (!commitExists(remoteRef))
			die(basedon + ' not pushed to ' + publishtoremote);

		var commit = callGitSync(['rev-parse', '-q', '--verify', remoteRef]);
		callGitSync(['rev-parse', basedon]) == commit ||
		die(basedon + ' on ' + publishtoremote +
		    ' disagrees with local branch');

		upstreamBranch = basedon;
	}

	!callGitSync(['rev-list', branchname + '..' + upstreamBranch]) ||
	die('Branch ' + shortname + ' is not rebased to ' + upstreamBranch);
};

function getCc(): void {
	// Cc: from config
	callGitSync(['config', '--get-all', 'branch.' + shortname + '.cc'],
			{ gentle: true } as GitOptions).split('\n').map(function(email) {
		!email ||
		cc.push(email);
	});
};

var subject_prefix: string | null = null, in_reply_to: string[] = [], branchdiff: string;

function determineIteration(): number {
	var latesttags: string[] = callGitSync(['for-each-ref', '--format=%(refname)',
			    '--sort=-taggerdate',
				'refs/tags/' + shortname + '-v*[0-9]']).split('\n');
	var latesttag: string;

	if (redo)
		latesttag = latesttags.length > 1 ? latesttags[1] : '';
	else
		latesttag = latesttags.length > 0 ? latesttags[0] : '';
	
	var patch_no: number;
	if (!latesttag) {
		patch_no = 1;
		subject_prefix = rfc ? '--subject-prefix=PATCH/RFC' : null;
		branchdiff = '';
	} else {
		var range = latesttag + '...' + branchname;
		callGitSync(['rev-list', range]) ||
		die('Branch ' + shortname + ' was already submitted: ' + latesttag);

		var match = latesttag.match(/-v([1-9][0-9]*)$/);
		patch_no = parseInt(match && match[1] || '0') + 1;
		subject_prefix = '--subject-prefix=PATCH' + (rfc ? '/RFC' : '') +
			' v' + patch_no;
		var tagMessage = callGitSync(['cat-file', 'tag', latesttag]);
		match = tagMessage.match(/^[\s\S]*?\n\n([\s\S]*)/);
		(match ? match[1] : tagMessage).split('\n').map(function(line) {
			match = line.match(/https:\/\/public-inbox\.org\/.*\/([^\/]+)/);
			if (!match)
				match = line.match(/https:\/\/www\.mail-archive\.com\/.*\/([^\/]+)/);
			if (!match)
				match = line.match(/http:\/\/mid.gmane.org\/(.*)/);
			if (!match)
				match = line.match(/^[^ :]*: Message-ID: ([^\/]+)/);
			if (match)
				in_reply_to.unshift(match[1]);
		});

		branchdiff = callGitSync(['tbdiff', '--no-color', range]);
	}

	if (dryRun)
		console.log('Dry-run ' + shortname + ' v' + patch_no);
	else
		console.log('Submitting ' + shortname + ' v' + patch_no);

	return patch_no;
};

var cover_letter: string | null = null;

function generateMBox(): string {
	// Auto-detect whether we need a cover letter
	if (gitConfig('branch.' + shortname + '.description'))
		cover_letter = '--cover-letter';
	else if (1 < parseInt(callGitSync(['rev-list', '--count',
		upstreamBranch + '..' + branchname])))
		die('Branch ' + shortname + ' needs a description');

	var commitRange = upstreamBranch + '..' + branchname;
	var args = [ 'format-patch', '--thread', '--stdout',
	    '--add-header=Fcc: Sent',
	    '--add-header=Content-Type: text/plain; charset=UTF-8',
	    '--add-header=Content-Transfer-Encoding: 8bit',
	    '--add-header=MIME-Version: 1.0',
	    '--base', upstreamBranch, to ];
	cc.map(email => { args.push('--cc=' + email); });
	in_reply_to.map(email => { args.push('--in-reply-to=' + email); });
	[ subject_prefix, cover_letter, patience]
	    .map(o => { o === null || args.push(o); });

	args.push(commitRange);
	console.log('Generating mbox');

	return callGitSync(args);
};

function insertCcAndFromLines(): void {
	var ident = callGitSync(['var', 'GIT_AUTHOR_IDENT']);
	var match = ident.match(/.*>/);
	var thisauthor = match && match[0];
	thisauthor || die('Could not determine author ident from ' + ident);
	var separatorRegex = /^From [0-9a-f]{40} Mon Sep 17 00:00:00 2001$/;

	console.log('Adding Cc: and explict From: lines for other authors, if needed');

	for (var i = 0; i < lines.length; i++) {
		if (!lines[i].match(separatorRegex))
			continue;
		var from = -1, cc = -1, author = null, cced = null;
		for (i = i + 1; i < lines.length && lines[i] != ''; i++) {
			var match = lines[i].match(/^(From|Cc): (.*)/);
			if (match && match[1] == 'From') {
				from < 0 || die('Duplicate From: header');
				from = i;
				author = match[2];
			} else if (match && match[2] == 'Cc') {
				cc < 0 || die('Duplicate Cc: header');
				cc = i;
				cced = match[2];
			}
		}
		from >= 0 || die('Missing From: line');
		if (author !== thisauthor) {
			lines[from] = 'From: ' + thisauthor;
			if (cc < 0) {
				lines.splice(from + 1, 0, 'Cc: ' + author);
				i++;
			} else
				lines[cc] = 'Cc: ' + author + ', ' + cced;
			lines.splice(i + 1, 0, 'From: ' + author, '');
		}
	}
};

function adjustCoverLetter(): void {
	if (cover_letter) {
		console.log('Fixing Subject: line of the cover letter');
		var subjectRegex = /^(Subject:.*) \*\*\* SUBJECT HERE \*\*\*$/;
		for (var i = 0; i < lines.length; i++) {
			var match = lines[i].match(subjectRegex);
			if (!match)
				continue;
			var subject = i;
			lines[subject] = match[1];

			while (i < lines.length && lines[i] !== '')
				i++;
			var body = i++;
			i + 3 < lines.length || die('Could not find cover letter');
			lines[i++] === '*** BLURB HERE ***' || die('No BLURB line?');
			lines[i++] === '' || die('Line after BLURB not empty');
			while (i < lines.length && lines[i] !== '') {
				lines[subject] += ' ' + lines[i];
				i++;
			}
			lines.splice(body, i - body);
		}
	}
};

function generateTagMessage(): string {
	console.log("Generating tag message");
	var tagmessage;

	if (!cover_letter)
		tagmessage = callGitSync(['cat-file', 'commit', branchname])
			.replace(/\n\n.*/, '');
	else {
		tagmessage = '';
		for (var i = 0; i < lines.length; i++) {
			var match = lines[i].match(/^Subject: (\[PATCH[^\]]*\] )?(.*)/);
			if (!match)
				continue;
			tagmessage = match[2];
			while (i < lines.length && lines[i] != '')
				i++;
			while (i < lines.length && lines[i] != '-- ')
				tagmessage += '\n' + lines[i++];
			break;
		}
	}

	return tagmessage;
};

function findFooter(): number {
	console.log("Finding location for the footers");
	var dashdash = 0;
	if (cover_letter)
		while (dashdash < lines.length && lines[dashdash] !== '-- ')
			dashdash++;
	else
		while (++dashdash < lines.length && lines[dashdash - 1] !== '---')
			dashdash++;
	return dashdash;
};

function insertLinks(): void {
	if (!publishtoremote)
		return;

	console.log('Inserting links');
	var url = gitConfig('remote.' + publishtoremote + '.url');
	var match = url.match(/^https?(:\/\/github\.com\/.*)/);
	if (match)
		url = 'https' + match[1];
	else if (match = url.match(/^(git@)?github\.com(:.*)/))
		url = 'https://github.com/' + match[1];
	else
		url = '';
	if (url) {
		if (basedon) {
			lines.splice(dashdash, 0,
				     'Based-On: ' + basedon + ' at ' + url,
				     'Fetch-Base-Via: git fetch '
				     + url + ' ' + basedon);
			dashdash += 2;
		}
		lines.splice(dashdash, 0,
			     'Published-As: ' + url + '/releases/tag/'
			     + tagname,
			     'Fetch-It-Via: git fetch ' + url + ' ' + tagname);
		dashdash += 2;
	}
};

function generateTagObject(): void {
	if (dryRun)
		console.log('Would generate tag object');
	else
		console.log('Generating tag object');

	var messageID = null;
	for (var i = 0; i < lines.length; i++) {
		var match = lines[i].match(/^Message-ID: <(.*)>/i);
		if (match) {
			messageID = match[1];
			break;
		}
	}

	tagmessage += '\n\nSubmitted-As: ' + midUrlPrefix + messageID;
	in_reply_to.map(id => {
		tagmessage += '\nIn-Reply-To: ' + midUrlPrefix + id;
	});
	args = ['tag', '-F', '-', '-a'];
	!redo || args.push('-f');
	args.push(tagname);
	if (dryRun)
		console.log("Tag name would be " + tagname
			    + " with message:\n\n"
			    + tagmessage.split('\n').map(line => {
				return '    ' + line;
			    }).join('\n'));
	else
		callGitSync(args, { 'input': tagmessage } as GitOptions);

	if (branchdiff) {
		console.log('Inserting branch-diff');
		// construct the arguments for split():
		// first, split the branch-diff and prefix with a space
		var args: any[] = branchdiff.split('\n').map(line => { return ' ' + line; });
		// now, shift in the (start, count) parameters, an empty line and the
		// "Branch-diff vs v$(($patch_no-1)):" label
		args.splice(0, 0, dashdash, 0,
			'', 'Branch-diff vs v' + (patch_no-1) + ':');
		// and finally call splice() using the apply() method on the prototype
		[].splice.apply(lines, args);
	}
};

function sendMBox(): void {
	if (dryRun) {
		console.log("Would send this mbox:\n\n"
			    + lines.map(line => {
				return '    ' + line;
			    }).join('\n'));
		return;
	}
	console.log('Calling the `send-mbox` alias');
	callGitSync(['send-mbox'], { 'input': lines.join('\n') } as GitOptions);
};

function publishBranch(): void {
	if (!publishtoremote || dryRun)
		return;

	console.log('Publishing branch and tag');
	if (redo)
		tagname = '+' + tagname;
	callGitSync(['push', publishtoremote, '+' + branchname, tagname]);
};

var shortname = getBranchName();
parseCommandLineOptions(process.argv);
var finishDryRun = () => {};
if (dryRun && typeof(process.env['GIT_PAGER_IN_USE']) === 'undefined') {
	var child_process = require('child_process');
	var args = [];
	if (typeof(process.env['LESS']) === 'undefined')
		args.push('-FRX');
	var options = { stdio: [ 'pipe', 'inherit', 'inherit' ] };
	var less = child_process.spawn('less', args, options);
	console.log = (msg: string) => {
		less.stdin.write(msg + '\n');
	};
	finishDryRun = () => {
		less.stdin.end();
		less.on('exit', () => { process.exit(); });
	};
	process.env['GIT_PAGER_IN_USE'] = 'true';
}
determineProject();
determineBaseBranch();
getCc();
var patch_no = determineIteration();
var lines = generateMBox().split('\n');
insertCcAndFromLines();
adjustCoverLetter();
var tagmessage = generateTagMessage();
var dashdash = findFooter();
var tagname = shortname + '-v' + patch_no;
insertLinks();
generateTagObject();
sendMBox();
publishBranch();
if (finishDryRun)
	finishDryRun();
